# 検証ルールリファレンス

本ドキュメントでは、要求管理MCPサーバーで実装されている全検証ルール（A-Eドメイン、計20ルール）の詳細を説明します。

## 目次

1. [A. 階層ルール（Hierarchy Rules）](#a-階層ルールhierarchy-rules) - 5ルール
2. [B. グラフヘルスルール（Graph Health Rules）](#b-グラフヘルスルールgraph-health-rules) - 5ルール
3. [C. 抽象度ルール（Abstraction Rules）](#c-抽象度ルールabstraction-rules) - 3ルール
4. [D. MECEルール（MECE Rules）](#d-meceルールmece-rules) - 3ルール
5. [E. 品質スタイルルール（Quality & Style Rules）](#e-品質スタイルルールquality--style-rules) - 5ルール

---

## A. 階層ルール（Hierarchy Rules）

要求の階層構造（stakeholder → system → system_functional）の整合性を検証します。

### A1: レベル間の関係制約

**重要度**: `error`
**説明**: 階層間の親子関係が正しいパターンに従っているかを検証します。

**ルール内容**:
- stakeholder要求は、system要求**のみ**を子に持つことができる
- system要求は、system_functional要求**のみ**を子に持つことができる
- 異なるレベルへの直接的なリンク（例: stakeholder → system_functional）は禁止

**違反例**:
```json
{
  "id": "STK-001",
  "type": "stakeholder",
  "refines": []
}
// 子要求
{
  "id": "FUNC-001",
  "type": "system_functional",
  "refines": ["STK-001"]  // ❌ stakeholder → system_functional は禁止
}
```

**修正方法**:
```json
// 中間にsystem要求を追加
{
  "id": "SYS-001",
  "type": "system",
  "refines": ["STK-001"]
}
{
  "id": "FUNC-001",
  "type": "system_functional",
  "refines": ["SYS-001"]  // ✅ system → system_functional は正しい
}
```

---

### A2: 親要求の存在チェック

**重要度**: `error`
**説明**: system要求とsystem_functional要求は、必ず親要求（refines）を持つ必要があります。

**ルール内容**:
- `system`要求は、少なくとも1つのstakeholder要求を親に持つ
- `system_functional`要求は、少なくとも1つのsystem要求を親に持つ
- `stakeholder`要求は親を持たなくてよい（トップレベル）

**違反例**:
```json
{
  "id": "SYS-001",
  "type": "system",
  "refines": []  // ❌ 親がない
}
```

**修正方法**:
```json
{
  "id": "SYS-001",
  "type": "system",
  "refines": ["STK-001"]  // ✅ 親要求を指定
}
```

---

### A3: 循環参照の禁止

**重要度**: `error`
**説明**: refinesエッジに循環参照があってはなりません。

**ルール内容**:
- 要求Aが要求Bを親に持ち、要求Bが要求Cを親に持つ場合、要求Cは要求Aを親に持つことができない
- 自己参照（自分自身をrefinesに含む）も禁止

**違反例**:
```json
// A → B → C → A という循環
{
  "id": "REQ-A",
  "refines": ["REQ-C"]  // ❌
},
{
  "id": "REQ-B",
  "refines": ["REQ-A"]
},
{
  "id": "REQ-C",
  "refines": ["REQ-B"]
}
```

**修正方法**: 循環を解消し、正しい階層関係を設計してください。

---

### A4: 最大階層深度

**重要度**: `warning`
**説明**: 要求の階層は3レベル（stakeholder → system → system_functional）を超えてはなりません。

**ルール内容**:
- 最大深度: 3レベル
- 過度に深い階層は、管理コストの増加と可読性の低下を招きます

**パラメータ**:
```jsonc
{
  "maxDepth": 3
}
```

**違反例**:
```
Level 1: stakeholder
  Level 2: system
    Level 3: system_functional
      Level 4: ... ❌ 4レベル目は警告
```

---

### A5: 子要求の存在チェック

**重要度**: `error`
**説明**: stakeholder要求とsystem要求は、少なくとも1つの子要求を持つ必要があります。

**ルール内容**:
- `stakeholder`要求は、少なくとも1つのsystem要求を子に持つ
- `system`要求は、少なくとも1つのsystem_functional要求を子に持つ
- `system_functional`要求は子要求を持たなくてよい（リーフノード）

**違反例**:
```json
{
  "id": "SYS-001",
  "type": "system",
  "refines": ["STK-001"]
}
// 子要求がない ❌
```

**修正方法**:
```json
{
  "id": "SYS-001",
  "type": "system",
  "refines": ["STK-001"]
}
// 子要求を追加
{
  "id": "FUNC-001",
  "type": "system_functional",
  "refines": ["SYS-001"]  // ✅
}
```

---

## B. グラフヘルスルール（Graph Health Rules）

要求間の関係グラフの健全性を検証します。

### B1: DAG検証

**重要度**: `error`
**説明**: depends_onエッジとrefinesエッジを合わせたグラフは、有向非巡回グラフ（DAG: Directed Acyclic Graph）でなければなりません。

**ルール内容**:
- 全体のグラフに循環があってはならない
- refinesとdepends_onの両方を含めて検証
- A3ルール（循環参照の禁止）の拡張版

**違反例**:
```json
{
  "id": "REQ-A",
  "depends_on": ["REQ-B"]
},
{
  "id": "REQ-B",
  "depends_on": ["REQ-A"]  // ❌ 依存関係の循環
}
```

---

### B2: ファンアウト制限

**重要度**: `warning`
**説明**: 1つの要求が持つ子要求（refinesの逆方向）の数は上限を超えてはなりません。

**ルール内容**:
- デフォルト上限: 10個
- 過度なファンアウトは、要求が適切に分解されていない可能性を示します

**パラメータ**:
```jsonc
{
  "maxChildren": 10
}
```

**違反例**:
```json
{
  "id": "SYS-001",
  "type": "system"
}
// 子要求が11個以上 ❌
```

**推奨**: 関連する子要求をグループ化し、中間レベルの要求を追加してください。

---

### B3: 孤立要求の検出

**重要度**: `info`
**説明**: 依存関係やrefinesエッジを持たない孤立要求を検出します。

**ルール内容**:
- refines、depends_on、conflicts_with、duplicatesのいずれも持たない要求を検出
- 情報レベルの通知（エラーではない）

**検出例**:
```json
{
  "id": "REQ-ISOLATED",
  "type": "system",
  "refines": [],
  "depends_on": []
  // ℹ️ 孤立要求として検出される
}
```

---

### B4: 競合関係の整合性

**重要度**: `warning`
**説明**: conflicts_withエッジは双方向対称でなければなりません。

**ルール内容**:
- 要求Aが要求Bと競合する場合、要求Bも要求Aと競合しなければならない

**違反例**:
```json
{
  "id": "REQ-A",
  "conflicts_with": ["REQ-B"]
},
{
  "id": "REQ-B",
  "conflicts_with": []  // ❌ 双方向になっていない
}
```

**修正方法**:
```json
{
  "id": "REQ-B",
  "conflicts_with": ["REQ-A"]  // ✅ 双方向に設定
}
```

---

### B5: 重複候補の妥当性

**重要度**: `warning`
**説明**: duplicatesエッジが指す要求は同じレベル（type）でなければなりません。

**ルール内容**:
- 重複候補は同じtype（stakeholder、system、system_functional）の要求同士であるべき

**違反例**:
```json
{
  "id": "SYS-001",
  "type": "system",
  "duplicates": ["FUNC-001"]  // ❌ system と system_functional は異なるレベル
}
```

---

## C. 抽象度ルール（Abstraction Rules）

要求の抽象度（具体性）の適切性を検証します。

### C1: 兄弟要求の抽象度一貫性

**重要度**: `warning`
**説明**: 同じ親を持つ兄弟要求群の抽象度スコアの分散が閾値を超えてはなりません。

**ルール内容**:
- 兄弟要求間で抽象度が大きくばらつくと、粒度が不揃いで管理が困難になる
- デフォルト最大分散: 0.15

**パラメータ**:
```jsonc
{
  "maxVariance": 0.15,
  "useLLMForBoundary": true
}
```

**違反例**:
```
親要求: SYS-001
  子1: "システムはデータを処理する" (abstraction_score: 0.9) 非常に抽象的
  子2: "GET /api/data エンドポイントで..." (abstraction_score: 0.2) 非常に具体的
  ⚠️ 分散が大きすぎる
```

---

### C2: 親子間の具体化度差

**重要度**: `warning`
**説明**: 子要求の抽象度は親要求より低い（より具体的）でなければなりません。

**ルール内容**:
- 最小差分: 0.1
- 子要求は親要求を「詳細化」するため、より具体的であるべき

**パラメータ**:
```jsonc
{
  "minDifference": 0.1,
  "useLLMForBoundary": true
}
```

**違反例**:
```
親要求: "ログイン機能を実装する" (abstraction_score: 0.3)
子要求: "認証システムを構築する" (abstraction_score: 0.8)  // ❌ 子の方が抽象的
```

---

### C3: 抽象度スコアの範囲チェック

**重要度**: `error`
**説明**: 抽象度スコアは0.0〜1.0の範囲内でなければなりません。

**ルール内容**:
- データ整合性のチェック
- 0.0 = 非常に具体的、1.0 = 非常に抽象的

---

## D. MECEルール（MECE Rules）

MECE（Mutually Exclusive, Collectively Exhaustive: 相互排他的かつ網羅的）の原則を検証します。

### D1: 兄弟要求間の重複検出

**重要度**: `warning`
**説明**: 同じ親を持つ兄弟要求間で意味的重複（類似度が閾値以上）を検出します。

**ルール内容**:
- 類似度閾値: 0.8（デフォルト）
- 埋め込みベクトルまたはLLMを使用して意味的類似度を計算

**パラメータ**:
```jsonc
{
  "similarityThreshold": 0.8,
  "useEmbeddings": true,
  "useLLMForBoundary": true
}
```

**違反例**:
```
親要求: "ユーザー認証"
  子1: "ログイン機能"
  子2: "サインイン機能"  // ⚠️ ログインとサインインは意味的に重複
```

---

### D2: 親要求のカバレッジ

**重要度**: `info`
**説明**: 親要求の内容が子要求群で十分にカバーされているかをLLMで評価します。

**ルール内容**:
- LLM評価が必須
- カバレッジが低い場合、親要求が十分に分解されていない可能性あり

**パラメータ**:
```jsonc
{
  "requireLLM": true
}
```

**検出例**:
```
親要求: "ユーザー管理機能（登録、編集、削除、権限管理を含む）"
  子要求: "ユーザー登録機能"のみ
  ℹ️ カバレッジが低い（25%程度）→ 編集、削除、権限管理の要求が不足
```

---

### D3: 細分化の妥当性

**重要度**: `info`
**説明**: 子要求が過度に細分化されていないかをチェックします（子要求数とサイズのバランス）。

**ルール内容**:
- 最大子要求数: 10
- 最小トークン数/子要求: 20

**パラメータ**:
```jsonc
{
  "maxChildren": 10,
  "minTokensPerChild": 20
}
```

**検出例**:
```
親要求: "データ処理機能"
  子要求が11個以上、かつ各子要求が非常に短い（10トークン未満）
  ℹ️ 過度に細分化されている可能性
```

---

## E. 品質スタイルルール（Quality & Style Rules）

要求文の品質と記述スタイルを検証します。

### E1: 曖昧な表現の検出

**重要度**: `warning`
**説明**: 「など」「適切に」「柔軟に」などの曖昧な表現を検出します。

**ルール内容**:
- 検出対象語:
  - 「など」「等」
  - 「適切に」「柔軟に」
  - 「必要に応じて」「可能な限り」
  - 「基本的に」「一般的に」

**パラメータ**:
```jsonc
{
  "vagueTerms": [
    "など", "等", "適切に", "柔軟に",
    "必要に応じて", "可能な限り", "基本的に", "一般的に"
  ]
}
```

**違反例**:
```
"データを適切に処理する"  // ❌ 「適切に」が曖昧
"エラー処理を必要に応じて実装する"  // ❌ 「必要に応じて」が曖昧
```

**修正方法**:
```
"データを検証し、不正な値はエラーログに記録する"  // ✅ 具体的
"HTTP 4xxエラーと5xxエラーをエラーログに記録する"  // ✅ 具体的
```

---

### E2: 受動態の検出

**重要度**: `info`
**説明**: 受動態の使用を検出し、能動態への書き換えを推奨します。

**ルール内容**:
- 検出パターン: 「される」「れる」「られる」
- 能動態の方が主語が明確で、責任範囲が明確になる

**パラメータ**:
```jsonc
{
  "passivePatterns": ["される", "れる", "られる"]
}
```

**違反例**:
```
"データが処理される"  // ℹ️ 受動態
"エラーが検出される"  // ℹ️ 受動態
```

**修正方法**:
```
"システムはデータを処理する"  // ✅ 能動態
"バリデーション機能がエラーを検出する"  // ✅ 能動態
```

---

### E3: 主語の明示

**重要度**: `warning`
**説明**: 要求の主語（誰が/何が）が明示されているかをチェックします。

**ルール内容**:
- LLM評価を使用（オプション）
- 主語が不明確な場合、責任範囲が曖昧になる

**パラメータ**:
```jsonc
{
  "requireActor": true,
  "useLLM": true
}
```

**違反例**:
```
"データを処理する"  // ⚠️ 誰が/何が処理するのか不明
```

**修正方法**:
```
"データ処理サービスがデータを処理する"  // ✅ 主語が明確
```

---

### E4: 長さの妥当性

**重要度**: `info`
**説明**: 要求の説明が短すぎる、または長すぎないかをチェックします。

**ルール内容**:
- 最小トークン数: 10
- 最大トークン数: 200

**パラメータ**:
```jsonc
{
  "minTokens": 10,
  "maxTokens": 200
}
```

**違反例**:
```
"ログイン"  // ℹ️ 短すぎる（2トークン）
"システムは、ユーザーが入力したユーザーIDとパスワードを検証し..." （200トークン以上）  // ℹ️ 長すぎる
```

---

### E5: 単一性チェック

**重要度**: `warning`
**説明**: 1つの要求が複数の関心事を含んでいないかをチェックします（atomicity_score使用）。

**ルール内容**:
- 最小単一性スコア: 0.7
- 複数の関心事が含まれる場合、要求を分割すべき

**パラメータ**:
```jsonc
{
  "minAtomicityScore": 0.7
}
```

**違反例**:
```
"ユーザーの登録、編集、削除を行う。また、権限管理も実装する。"
// ⚠️ atomicity_score = 0.3 （4つの関心事が含まれている）
```

**修正方法**:
```
// 4つの要求に分割
1. "ユーザー登録機能を実装する"  // ✅ 単一の関心事
2. "ユーザー編集機能を実装する"  // ✅ 単一の関心事
3. "ユーザー削除機能を実装する"  // ✅ 単一の関心事
4. "ユーザー権限管理機能を実装する"  // ✅ 単一の関心事
```

---

## ルールのカスタマイズ

### ルールの有効/無効切り替え

`config/validation-rules.jsonc` ファイルで各ルールの `enabled` フィールドを変更します:

```jsonc
{
  "id": "E1",
  "enabled": false,  // このルールを無効化
  // ...
}
```

### パラメータの調整

各ルールの `parameters` フィールドでパラメータを調整できます:

```jsonc
{
  "id": "B2",
  "parameters": {
    "maxChildren": 15  // デフォルトの10から15に変更
  }
}
```

### LLM評価の有効化

一部のルール（C1, C2, D1, D2, E3）はLLM評価をサポートしています。使用するには:

1. `ANTHROPIC_API_KEY` 環境変数を設定
2. ルールパラメータで `useLLM: true` または `requireLLM: true` を設定
3. 検証時に `useLLM: true` オプションを指定

---

## まとめ

本システムは**5つのドメインで計20個の検証ルール**を提供します:

| ドメイン | ルール数 | 主な目的 |
|----------|----------|----------|
| **A. 階層** | 5 | 要求の階層構造の整合性 |
| **B. グラフヘルス** | 5 | 要求間の関係グラフの健全性 |
| **C. 抽象度** | 3 | 要求の抽象度（具体性）の適切性 |
| **D. MECE** | 3 | 相互排他性と網羅性の検証 |
| **E. 品質スタイル** | 5 | 要求文の品質と記述スタイル |

これらのルールにより、**高品質な要求仕様書の作成と維持**を支援します。
